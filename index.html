<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Live USDT Screener</title>
  <style>
    body {
      background: #1e1e1e;
      color: #eee;
      font-family: Arial, sans-serif;
      padding: 20px;
    }
    .warning {
      background: #ff6b35;
      color: white;
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 20px;
      text-align: center;
      font-weight: bold;
    }
    input, select, button {
      margin: 6px;
      padding: 6px;
      background: #2b2b2b;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
    }
    .breakout-btn {
      background: #4CAF50;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin: 10px 0;
    }
    .breakout-btn:hover { background: #45a049; }
    .coin-row {
      background: #333;
      padding: 8px;
      border-radius: 5px;
      margin-top: 10px;
    }
    .coin-row.breakout {
      background: #2d4a2d;
      border-left: 4px solid #4CAF50;
    }
    .coin-row span { display: block; }
    .coin-row .actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .technical-indicators {
      display: flex;
      gap: 15px;
      margin-top: 5px;
      flex-wrap: wrap;
    }
    .indicator {
      background: #444;
      padding: 4px 8px;
      border-radius: 3px;
      font-size: 12px;
    }
    .indicator.bullish {
      background: #2d4a2d;
      color: #4CAF50;
    }
    .indicator.bearish {
      background: #4a2d2d;
      color: #f44336;
    }
    .loading {
      text-align: center;
      padding: 20px;
      color: #aaa;
    }
  </style>
</head>
<body>
  <div class="warning">
    ‚ö†Ô∏è DISCLAIMER: This tool is for educational purposes only. This is NOT financial advice. Always do your own research before making investment decisions.
  </div>

  <h2>Live USDT Screener</h2>
  <div id="timestamp"></div><br>

  <div>
    <button class="breakout-btn" onclick="findBreakouts()">üöÄ Find Breakout Coins</button>
    <br><br>

    <label>Search Coin:</label>
    <input type="text" id="searchInput" placeholder="e.g. BTC">
    <button onclick="searchCoin()">Search</button><br><br>

    <label>Market Cap From (Millions):</label><br>
    <input id="mcapMin" type="number" value="10"><br>
    <label>To:</label><br>
    <input id="mcapMax" type="number" value="500"><br><br><br>

    <label>Volume 24h From (Millions):</label><br>
    <input id="volMin" type="number" value="5"><br>
    <label>To:</label><br>
    <input id="volMax" type="number" value="150"><br><br><br>

    <label>Price Change 24h (%):</label>
    <input type="range" id="priceMin" min="-20" max="40" value="-20" oninput="document.getElementById('minLabel').innerText = this.value">
    <span id="minLabel">-20</span>
    <input type="range" id="priceMax" min="-20" max="200" value="20" oninput="document.getElementById('maxLabel').innerText = this.value">
    <span id="maxLabel">20</span>

    <br />
    <label>Timeframe:</label>
    <select id="timeframe">
      <option value="15m">15m</option>
      <option value="30m">30m</option>
      <option value="1h">1h</option>
      <option value="4h">4h</option>
      <option value="1d">1D</option>
      <option value="1w">1W</option>
    </select>

    <br />
    <input type="checkbox" id="lowerLows"> <label for="lowerLows">Consecutive Lower Close Prices</label>
    <input type="number" id="lowerCount" value="2" min="2">
    <br />
    <input type="checkbox" id="higherHighs"> <label for="higherHighs">Consecutive Higher Close Prices</label>
    <input type="number" id="higherCount" value="2" min="2">

    <br />
    <button onclick="runScreener()">Filter</button>
  </div>

  <div id="results"></div>

  <script>
    let geckoCoins = [];
    let symbolToCoin = {};
    let symbolToVolumeRank = {};

    function updateTimestamp() {
      const now = new Date();
      const utc4 = new Date(now.getTime() - 4 * 60 * 60 * 1000);
      document.getElementById('timestamp').innerHTML = `<strong>UTC-4 Time:</strong> ${utc4.toUTCString()}`;
    }
    updateTimestamp();
    setInterval(updateTimestamp, 60000);

    async function getCoinGeckoData() {
      const res = await fetch("https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=volume_desc&per_page=200&page=1&sparkline=false");
      const data = await res.json();
      geckoCoins = data;
      symbolToCoin = Object.fromEntries(data.map(coin => [coin.symbol.toUpperCase(), coin]));

      const binanceSymbolsInfo = await fetch("https://api.binance.com/api/v3/ticker/24hr").then(r => r.json());
      const binanceUSDT = binanceSymbolsInfo.filter(c => c.symbol.endsWith("USDT"));
      symbolToVolumeRank = Object.fromEntries(
        binanceUSDT
          .sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume))
          .map((s, i) => [s.symbol, i + 1])
      );

      return data;
    }

    // Technical Analysis Functions
    function calculateSMA(data, period) {
      const sma = [];
      for (let i = period - 1; i < data.length; i++) {
        const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
        sma.push(sum / period);
      }
      return sma;
    }

    function calculateRSI(closes, period = 14) {
      if (closes.length < period + 1) return [];
      const gains = [];
      const losses = [];
      for (let i = 1; i < closes.length; i++) {
        const change = closes[i] - closes[i - 1];
        gains.push(change > 0 ? change : 0);
        losses.push(change < 0 ? Math.abs(change) : 0);
      }
      const avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
      const avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
      const rsi = [];
      let currentAvgGain = avgGain;
      let currentAvgLoss = avgLoss;
      for (let i = period; i < gains.length; i++) {
        currentAvgGain = ((currentAvgGain * (period - 1)) + gains[i]) / period;
        currentAvgLoss = ((currentAvgLoss * (period - 1)) + losses[i]) / period;
        const rs = currentAvgGain / currentAvgLoss;
        rsi.push(100 - (100 / (1 + rs)));
      }
      return rsi;
    }

    function calculateStochRSI(rsi, period = 14) {
      if (rsi.length < period) return [];
      const stochRSI = [];
      for (let i = period - 1; i < rsi.length; i++) {
        const rsiPeriod = rsi.slice(i - period + 1, i + 1);
        const minRSI = Math.min(...rsiPeriod);
        const maxRSI = Math.max(...rsiPeriod);
        if (maxRSI - minRSI === 0) {
          stochRSI.push(0);
        } else {
          stochRSI.push((rsi[i] - minRSI) / (maxRSI - minRSI) * 100);
        }
      }
      return stochRSI;
    }

    function detectResistanceBreakout(highs, closes, volume, period = 20) {
      if (highs.length < period + 5) return false;
      const recent = highs.slice(-period);
      const recentVolume = volume.slice(-period);
      const avgVolume = recentVolume.reduce((a, b) => a + b, 0) / recentVolume.length;
      const resistanceLevel = Math.max(...recent.slice(0, -3));
      const currentPrice = closes[closes.length - 1];
      const currentVolume = volume[volume.length - 1];
      return currentPrice > resistanceLevel && currentVolume > avgVolume * 1.2;
    }

    async function getKlineData(symbol, interval = '1h', limit = 100) {
      try {
        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`);
        const data = await response.json();
        return data.map(candle => ({
          open: parseFloat(candle[1]),
          high: parseFloat(candle[2]),
          low: parseFloat(candle[3]),
          close: parseFloat(candle[4]),
          volume: parseFloat(candle[5])
        }));
      } catch (error) {
        console.error(`Error fetching kline data for ${symbol}:`, error);
        return [];
      }
    }

    // Candle logic helpers
    function hasConsecutiveLowerCloses(closes, count) {
      for (let i = closes.length - count; i < closes.length - 1; i++) {
        if (closes[i] <= closes[i+1]) return false;
      }
      return true;
    }
    function hasConsecutiveHigherCloses(closes, count) {
      for (let i = closes.length - count; i < closes.length - 1; i++) {
        if (closes[i] >= closes[i+1]) return false;
      }
      return true;
    }

    // FILTER SCREEN
    async function runScreener() {
      const mcapMin = +document.getElementById('mcapMin').value * 1e6;
      const mcapMax = +document.getElementById('mcapMax').value * 1e6;
      const volMin = +document.getElementById('volMin').value * 1e6;
      const volMax = +document.getElementById('volMax').value * 1e6;
      const priceMin = +document.getElementById('priceMin').value;
      const priceMax = +document.getElementById('priceMax').value;
      const tf = document.getElementById('timeframe').value;

      const lowerLowsChecked = document.getElementById('lowerLows').checked;
      const lowerCount = +document.getElementById('lowerCount').value;
      const higherHighsChecked = document.getElementById('higherHighs').checked;
      const higherCount = +document.getElementById('higherCount').value;

      const results = document.getElementById('results');
      results.innerHTML = '‚è≥ Fetching data...';

      const binanceSymbols = new Set(Object.keys(symbolToVolumeRank));
      const filteredCoins = [];

      for (const coin of geckoCoins) {
        const symbol = (coin.symbol + "USDT").toUpperCase();
        if (!binanceSymbols.has(symbol)) continue;

        const marketCap = coin.market_cap;
        const volume = coin.total_volume;
        const priceChange = coin.price_change_percentage_24h;
        const rank = symbolToVolumeRank[symbol];

        if (
          marketCap < mcapMin || marketCap > mcapMax ||
          volume < volMin || volume > volMax ||
          priceChange < priceMin || priceChange > priceMax
        ) continue;

        // Candle filter logic
        if (lowerLowsChecked || higherHighsChecked) {
          const klineData = await getKlineData(symbol, tf, Math.max(lowerCount, higherCount));
          const closes = klineData.map(k => k.close);
          let pass = true;
          if (lowerLowsChecked && !hasConsecutiveLowerCloses(closes, lowerCount)) pass = false;
          if (higherHighsChecked && !hasConsecutiveHigherCloses(closes, higherCount)) pass = false;
          if (!pass) continue;
        }

        filteredCoins.push({ symbol, marketCap, volume, priceChange, rank });
      }

      filteredCoins.sort((a, b) => a.rank - b.rank);

      results.innerHTML = '';
      for (const coin of filteredCoins) {
        const row = document.createElement('div');
        row.className = 'coin-row';
        row.innerHTML = `
          <div class="actions">
            <span><strong>${coin.symbol}</strong> (Volume Rank: #${coin.rank})</span>
            <button onclick="window.open('https://www.tradingview.com/chart/?symbol=BINANCE:${coin.symbol}&interval=${tf}', '_blank')">View</button>
          </div>
          <div>
            <small>Market Cap: <strong>${formatMarketCap(coin.marketCap)}</strong></small><br>
            <small>Volume (24h): <strong>${formatMarketCap(coin.volume)}</strong></small><br>
            <small>Change (24h): <strong>${coin.priceChange.toFixed(2)}%</strong></small>
          </div>
        `;
        results.appendChild(row);
      }
    }

    // BREAKOUT SCREEN (unchanged)
    async function findBreakouts() {
      const results = document.getElementById('results');
      const timeframe = document.getElementById('timeframe').value;

      results.innerHTML = '<div class="loading">üîç Analyzing breakout patterns... This may take a moment.</div>';

      const binanceSymbols = Object.keys(symbolToVolumeRank).slice(0, 50);
      const breakoutCoins = [];

      const mcapMin = +document.getElementById('mcapMin').value * 1e6;
      const mcapMax = +document.getElementById('mcapMax').value * 1e6;
      const volMin = +document.getElementById('volMin').value * 1e6;
      const volMax = +document.getElementById('volMax').value * 1e6;
      const priceMin = +document.getElementById('priceMin').value;
      const priceMax = +document.getElementById('priceMax').value;

      for (const symbol of binanceSymbols) {
        try {
          const klineData = await getKlineData(symbol, timeframe, 100);
          if (klineData.length < 50) continue;

          const closes = klineData.map(k => k.close);
          const highs = klineData.map(k => k.high);
          const volumes = klineData.map(k => k.volume);

          const rsi = calculateRSI(closes);
          const stochRSI = calculateStochRSI(rsi);

          if (rsi.length === 0 || stochRSI.length === 0) continue;

          const currentRSI = rsi[rsi.length - 1];
          const currentStochRSI = stochRSI[stochRSI.length - 1];
          const isBreakout = detectResistanceBreakout(highs, closes, volumes);

          if (isBreakout && currentRSI > 50 && currentStochRSI > 20) {
            const baseSymbol = symbol.replace('USDT', '');
            const coinInfo = symbolToCoin[baseSymbol];
            if (coinInfo) {
              const marketCap = coinInfo.market_cap;
              const volume = coinInfo.total_volume;
              const priceChange = coinInfo.price_change_percentage_24h;

              if (
                marketCap >= mcapMin &&
                marketCap <= mcapMax &&
                volume >= volMin &&
                volume <= volMax &&
                priceChange >= priceMin &&
                priceChange <= priceMax
              ) {
                breakoutCoins.push({
                  symbol,
                  coinInfo,
                  rsi: currentRSI,
                  stochRSI: currentStochRSI,
                  rank: symbolToVolumeRank[symbol],
                  priceChange: coinInfo.price_change_percentage_24h
                });
              }
            }
          }
          await new Promise(resolve => setTimeout(resolve, 100));
        } catch (error) {
          console.error(`Error analyzing ${symbol}:`, error);
        }
      }

      breakoutCoins.sort((a, b) => a.rank - b.rank);

      results.innerHTML = '';

      if (breakoutCoins.length === 0) {
        results.innerHTML = '<div class="coin-row">No breakout patterns detected at this time.</div>';
        return;
      }

      breakoutCoins.forEach(coin => {
        const row = document.createElement('div');
        row.className = 'coin-row breakout';
        row.innerHTML = `
          <div class="actions">
            <span><strong>${coin.symbol}</strong> - ${coin.coinInfo.name} (Volume Rank: #${coin.rank}) üöÄ</span>
            <button onclick="window.open('https://www.tradingview.com/chart/?symbol=BINANCE:${coin.symbol}&interval=${timeframe}', '_blank')">View Chart</button>
          </div>
          <div>
            <small>Market Cap: <strong>${formatMarketCap(coin.coinInfo.market_cap)}</strong></small><br>
            <small>Volume (24h): <strong>${formatMarketCap(coin.coinInfo.total_volume)}</strong></small><br>
            <small>Change (24h): <strong>${coin.priceChange.toFixed(2)}%</strong></small>
          </div>
          <div class="technical-indicators">
            <div class="indicator ${coin.rsi > 70 ? 'bullish' : coin.rsi < 30 ? 'bearish' : ''}">
              RSI: ${coin.rsi.toFixed(1)}
            </div>
            <div class="indicator ${coin.stochRSI > 80 ? 'bullish' : coin.stochRSI < 20 ? 'bearish' : ''}">
              Stoch RSI: ${coin.stochRSI.toFixed(1)}
            </div>
            <div class="indicator">
              Breakout: ‚úÖ
            </div>
          </div>
        `;
        results.appendChild(row);
      });
    }

    function formatMarketCap(value) {
      return value >= 1e9 ? (value / 1e9).toFixed(2) + ' Billion' : (value / 1e6).toFixed(2) + ' Million';
    }

    async function searchCoin() {
      const input = document.getElementById("searchInput").value.trim().toUpperCase();
      const tf = document.getElementById("timeframe").value;
      const results = document.getElementById("results");
      results.innerHTML = '';
      const coin = symbolToCoin[input];
      if (!coin) {
        results.innerHTML = `<div class='coin-row'>Coin ${input} not found.</div>`;
        return;
      }

      const symbol = (coin.symbol + "USDT").toUpperCase();
      const rank = symbolToVolumeRank[symbol] || 'N/A';

      const klineData = await getKlineData(symbol, tf, 100);
      let rsi = null, stochRSI = null;

      if (klineData.length > 20) {
        const closes = klineData.map(k => k.close);
        const rsiData = calculateRSI(closes);
        const stochRSIData = calculateStochRSI(rsiData);

        if (rsiData.length > 0) rsi = rsiData[rsiData.length - 1];
        if (stochRSIData.length > 0) stochRSI = stochRSIData[stochRSIData.length - 1];
      }

      const row = document.createElement('div');
      row.className = 'coin-row';
      row.innerHTML = `
        <div class="actions">
          <span><strong>${symbol}</strong> - ${coin.name} (Volume Rank: #${rank})</span>
          <button onclick="window.open('https://www.tradingview.com/chart/?symbol=BINANCE:${symbol}&interval=${tf}', '_blank')">View</button>
        </div>
        <div>
          <small>Market Cap: <strong>${formatMarketCap(coin.market_cap)}</strong></small><br>
          <small>Volume (24h): <strong>${formatMarketCap(coin.total_volume)}</strong></small><br>
          <small>Change (24h): <strong>${coin.price_change_percentage_24h.toFixed(2)}%</strong></small>
        </div>
        ${rsi !== null ? `
        <div class="technical-indicators">
          <div class="indicator ${rsi > 70 ? 'bullish' : rsi < 30 ? 'bearish' : ''}">
            RSI: ${rsi.toFixed(1)}
          </div>
          ${stochRSI !== null ? `
          <div class="indicator ${stochRSI > 80 ? 'bullish' : stochRSI < 20 ? 'bearish' : ''}">
            Stoch RSI: ${stochRSI.toFixed(1)}
          </div>
          ` : ''}
        </div>
        ` : ''}
      `;
      results.appendChild(row);
    }

    getCoinGeckoData();
  </script>
</body>
</html>
